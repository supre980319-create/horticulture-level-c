<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>測驗中｜官方考試模式</title>
  <style>
    :root{--bg:#f4f6fb;--card:#fff;--text:#0f172a;--muted:#64748b;--primary:#2563eb;--border:#e5e7eb;--shadow:0 10px 30px rgba(15,23,42,.08);--ok:#16a34a;--bad:#dc2626;}
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans TC,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1120px;margin:0 auto;padding:18px 16px 36px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:18px;box-shadow:var(--shadow);padding:16px}
    .topbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .pills{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:10px 12px;border-radius:999px;background:#eef2ff;color:#1e3a8a;font-weight:700}
    .pill.muted{background:#f1f5f9;color:#334155}
    .pill.warn{background:#fff7ed;color:#9a3412}
    .titleRow{display:flex;align-items:center;justify-content:space-between;margin-top:10px}
    h2{margin:0;font-size:20px}
    .hint{color:var(--muted)}
    .imgBox{margin-top:12px;border:1px dashed #cbd5e1;border-radius:16px;background:#f8fafc;min-height:380px;display:flex;align-items:center;justify-content:center;padding:14px}
    .imgBox img{max-width:100%;max-height:520px;border-radius:12px;border:2px solid #ef4444;object-fit:contain;background:#0b1220}
    .options{margin-top:14px;display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .opt{border:1px solid var(--border);border-radius:14px;padding:12px 12px;display:flex;gap:10px;align-items:center;cursor:pointer;background:#fff}
    .opt input{width:18px;height:18px}
    .opt b{min-width:26px}
    .opt.selected{outline:2px solid rgba(37,99,235,.35);border-color:#bfdbfe}
    .opt.locked{cursor:not-allowed;opacity:.95}
    .controls{margin-top:14px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .btn{height:44px;border:0;border-radius:12px;padding:0 16px;font-weight:800;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff}
    .btn.ghost{background:#eef2ff;color:#1e3a8a}
    .btn.gray{background:#e2e8f0;color:#0f172a}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .navWrap{margin-top:14px}
    .navTitle{font-weight:800;margin-bottom:8px}
    .grid{display:grid;grid-template-columns:repeat(10, minmax(0,1fr));gap:8px}
    .qbtn{height:38px;border-radius:10px;border:1px solid var(--border);background:#fff;cursor:pointer;font-weight:800}
    .qbtn.active{outline:2px solid rgba(37,99,235,.35);border-color:#bfdbfe;background:#eff6ff}
    .qbtn.answered{background:#dcfce7;border-color:#bbf7d0}
    .qbtn.wrong{background:#fee2e2;border-color:#fecaca}
    .qbtn.hidden{display:none}
    .foot{margin-top:10px;color:var(--muted);font-size:13px;line-height:1.6}
    @media (max-width:820px){.options{grid-template-columns:1fr}.grid{grid-template-columns:repeat(8, minmax(0,1fr));}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="pills">
          <span class="pill muted">考生：<span id="studentId">—</span></span>
          <span class="pill muted">題數：<span id="totalN">—</span></span>
          <span class="pill" id="timerPill">剩餘：<span id="timer">--:--</span></span>
          <span class="pill warn" id="modePill" style="display:none">回看模式鎖定（不可改答案）</span>
        </div>
        <div class="hint" id="modeHint"></div>
      </div>

      <div class="titleRow">
        <h2 id="qTitle">第 1 / 100 題</h2>
        <div class="hint" id="subHint">（可前後翻題）</div>
      </div>

      <div class="imgBox">
        <img id="qImg" alt="題目圖片" />
      </div>

      <div class="options" id="options"></div>

      <div class="controls">
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn gray" id="prevBtn">上一題</button>
          <button class="btn gray" id="nextBtn">下一題</button>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn ghost" id="saveExitBtn">儲存並離開</button>
          <button class="btn primary" id="submitBtn">交卷</button>
        </div>
      </div>

      <div class="navWrap">
        <div class="navTitle">題目導覽</div>
        <div class="grid" id="navGrid"></div>
      </div>

      <div class="foot" id="ruleText">
        規則：每題 1 個正確選項 + 3 個錯誤選項；本次測驗 100 題固定順序。回看模式可在結果頁點題目進入。
      </div>
    </div>
  </div>

<script>
(() => {
  const LS = { quizState:'quizState_v2', result:'result_v2' };
  const QUESTION_SOURCE = './questions.json'; // 題庫檔（同資料夾）

  const el = (id)=>document.getElementById(id);
  const studentIdEl = el('studentId');
  const totalNEl = el('totalN');
  const timerEl = el('timer');
  const timerPill = el('timerPill');
  const modePill = el('modePill');
  const modeHint = el('modeHint');
  const qTitle = el('qTitle');
  const qImg = el('qImg');
  const optionsBox = el('options');
  const navGrid = el('navGrid');
  const prevBtn = el('prevBtn');
  const nextBtn = el('nextBtn');
  const submitBtn = el('submitBtn');
  const saveExitBtn = el('saveExitBtn');

  const LETTERS = ['A','B','C','D'];

  function safeParse(s){ try{ return JSON.parse(s); }catch{ return null; } }
  function readState(){ return safeParse(localStorage.getItem(LS.quizState) || 'null'); }
  function writeState(s){ localStorage.setItem(LS.quizState, JSON.stringify(s)); }
  function writeResult(r){ localStorage.setItem(LS.result, JSON.stringify(r)); }

  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  function hashStr(str){
    let h=2166136261>>>0;
    for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = Math.imul(h, 16777619); }
    return h>>>0;
  }
  function shuffleInPlace(arr, rnd){
    for (let i=arr.length-1;i>0;i--){
      const j = Math.floor(rnd()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function pickN(arr, n, rnd){
    const copy = arr.slice();
    shuffleInPlace(copy, rnd);
    return copy.slice(0, n);
  }

  function normalizeQuestionSource(data){
    // 允許：Array 或 Object(分類->陣列)
    const out = [];
    if (Array.isArray(data)){
      for (const it of data){
        if (!it) continue;
        if (typeof it === 'string'){
          out.push({ imgUrl: it, label: deriveLabelFromUrl(it) });
        } else {
          const imgUrl = it.imgUrl || it.url || it.image || it.src;
          const label = it.label || it.answer || it.name || it.title || it.correct;
          if (imgUrl) out.push({ imgUrl, label: label || deriveLabelFromUrl(imgUrl) });
        }
      }
      return out;
    }
    if (data && typeof data === 'object'){
      for (const [k, v] of Object.entries(data)){
        if (!Array.isArray(v)) continue;
        for (const it of v){
          if (!it) continue;
          if (typeof it === 'string'){
            out.push({ imgUrl: it, label: deriveLabelFromUrl(it), group:k });
          } else {
            const imgUrl = it.imgUrl || it.url || it.image || it.src;
            const label = it.label || it.answer || it.name || it.title || it.correct || k;
            if (imgUrl) out.push({ imgUrl, label, group:k });
          }
        }
      }
      return out;
    }
    return out;
  }

  function deriveLabelFromUrl(url){
    try{
      const u = new URL(url, location.href);
      const last = u.pathname.split('/').pop() || '';
      const noExt = last.replace(/\.[a-z0-9]+$/i,'');
      const decoded = decodeURIComponent(noExt);
      // 常見：同名多張不同角度「名稱_001」-> 取前段
      return decoded.replace(/[_-]\d+$/,'');
    }catch{
      const last = (url||'').split('/').pop() || '';
      return last.replace(/\.[a-z0-9]+$/i,'').replace(/[_-]\d+$/,'');
    }
  }

  async function fetchQuestionPool(){
    const res = await fetch(QUESTION_SOURCE, {cache:'no-store'});
    if (!res.ok) throw new Error('題庫讀取失敗：' + res.status);
    const data = await res.json();
    const pool = normalizeQuestionSource(data);
    // 去掉沒有 label 的
    return pool.filter(x=>x.imgUrl && x.label);
  }

  function buildExamQuestions(pool, seed, total=100){
    // 建立全局 label pool（去重）
    const labels = Array.from(new Set(pool.map(p => String(p.label).trim()).filter(Boolean)));
    const rnd = mulberry32(seed>>>0);

    // 固定順序：用 seed 洗牌後取前 100（一次作答固定，不會跳）
    const order = pool.slice();
    shuffleInPlace(order, rnd);
    const chosen = order.slice(0, Math.min(total, order.length));

    const questions = chosen.map((item, idx) => {
      const qid = 'Q' + String(idx+1).padStart(3,'0') + '_' + hashStr(item.imgUrl + '|' + item.label).toString(16);
      const correctText = String(item.label).trim();
      const wrongPool = labels.filter(x => x !== correctText);
      const rnd2 = mulberry32(hashStr(qid));
      const wrongs = pickN(wrongPool, 3, rnd2);
      // 不足 3 個錯誤時：以「(無)」補齊，避免 options 空白
      while (wrongs.length < 3) wrongs.push('（題庫不足）');
      const options = [correctText, ...wrongs];
      shuffleInPlace(options, rnd2); // 讓 A-D 每題固定（由 qid 決定）
      const correctIndex = options.indexOf(correctText);
      return { qid, idx, imgUrl: item.imgUrl, correctText, options, correctIndex };
    });

    if (questions.length < total){
      // 如果題庫不足 100，就用循環補齊，但 qid 仍唯一
      let i = questions.length;
      while (questions.length < total && pool.length){
        const base = pool[i % pool.length];
        const qid = 'Q' + String(questions.length+1).padStart(3,'0') + '_' + hashStr(base.imgUrl + '|' + base.label + '|' + questions.length).toString(16);
        const correctText = String(base.label).trim();
        const labels2 = Array.from(new Set(pool.map(p => String(p.label).trim()))).filter(Boolean);
        const wrongPool = labels2.filter(x => x !== correctText);
        const rnd2 = mulberry32(hashStr(qid));
        const wrongs = pickN(wrongPool, 3, rnd2);
        while (wrongs.length < 3) wrongs.push('（題庫不足）');
        const options = [correctText, ...wrongs];
        shuffleInPlace(options, rnd2);
        const correctIndex = options.indexOf(correctText);
        questions.push({ qid, idx: questions.length, imgUrl: base.imgUrl, correctText, options, correctIndex });
        i++;
      }
    }

    return questions;
  }

  function fmtTime(sec){
    const s = Math.max(0, Math.floor(sec));
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }

  function computeRemaining(state){
    if (state.phase === 'review') return 0;
    const elapsed = (Date.now() - state.startAt) / 1000;
    return state.durationSec - elapsed;
  }

  function ensureReviewList(state){
    const result = safeParse(localStorage.getItem(LS.result) || 'null');
    if (!result || !Array.isArray(result.items)) return null;
    if (state.reviewOnlyWrong){
      return result.items.filter(x => !x.ok).map(x => x.idx);
    }
    return result.items.map(x => x.idx);
  }

  function currentQuestion(state, list){
    const idx = list ? list[state.reviewPos || 0] : state.currentIndex;
    return state.questions[idx];
  }

  function setCurrentIndex(state, idx){
    if (state.phase === 'review'){
      // reviewPos refers to position in review list (filtered)
      const list = ensureReviewList(state);
      if (!list || !list.length) return;
      const pos = Math.max(0, Math.min(idx, list.length-1));
      state.reviewPos = pos;
    } else {
      state.currentIndex = Math.max(0, Math.min(idx, state.questions.length-1));
    }
    writeState(state);
    render(state);
  }

  function renderNav(state){
    navGrid.innerHTML = '';
    const result = safeParse(localStorage.getItem(LS.result) || 'null');
    const answeredMap = state.answers || {};
    const list = (state.phase === 'review') ? ensureReviewList(state) : null;
    const total = state.questions.length;

    const indices = list ? list : Array.from({length: total}, (_,i)=>i);

    indices.forEach((qIdx, pos) => {
      const q = state.questions[qIdx];
      const btn = document.createElement('button');
      btn.className = 'qbtn';
      btn.textContent = (qIdx+1);

      // 狀態顏色：作答中用 answered；回看可用 wrong 標記
      const sel = answeredMap[q.qid];
      if (sel !== undefined) btn.classList.add('answered');

      if (state.phase === 'review' && result && result.items){
        const it = result.items.find(x => x.qid === q.qid);
        if (it && !it.ok) btn.classList.add('wrong');
      }

      const activeIdx = (state.phase === 'review') ? (list ? list[state.reviewPos||0] : state.currentIndex) : state.currentIndex;
      if (qIdx === activeIdx) btn.classList.add('active');

      btn.addEventListener('click', () => {
        if (state.phase === 'review'){
          setCurrentIndex(state, pos);
        } else {
          setCurrentIndex(state, qIdx);
        }
      });
      navGrid.appendChild(btn);
    });
  }

  function renderQuestion(state){
    const list = (state.phase === 'review') ? ensureReviewList(state) : null;
    const q = currentQuestion(state, list);
    if (!q) return;

    const displayNumber = q.idx + 1;
    qTitle.textContent = `第 ${displayNumber} / ${state.questions.length} 題`;

    qImg.src = q.imgUrl;
    qImg.onerror = () => { qImg.alt = '圖片載入失敗'; };

    optionsBox.innerHTML = '';
    const selected = (state.answers || {})[q.qid];

    q.options.forEach((text, i) => {
      const row = document.createElement('label');
      row.className = 'opt' + (selected === i ? ' selected' : '') + (state.phase==='review' ? ' locked' : '');
      row.innerHTML = `<input type="radio" name="opt" ${selected===i?'checked':''} ${state.phase==='review'?'disabled':''} />
                       <b>${LETTERS[i]}.</b>
                       <span>${escapeHtml(text)}</span>`;
      row.addEventListener('click', (ev) => {
        if (state.phase === 'review') return;
        // update selection
        state.answers = state.answers || {};
        state.answers[q.qid] = i;
        writeState(state);
        render(state);
      });
      optionsBox.appendChild(row);
    });

    // prev/next disable
    if (state.phase === 'review'){
      const list2 = ensureReviewList(state) || [];
      const pos = state.reviewPos || 0;
      prevBtn.disabled = pos <= 0;
      nextBtn.disabled = pos >= list2.length-1;
    } else {
      prevBtn.disabled = state.currentIndex <= 0;
      nextBtn.disabled = state.currentIndex >= state.questions.length-1;
    }
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function render(state){
    studentIdEl.textContent = state.studentId || '—';
    totalNEl.textContent = state.questions ? state.questions.length : '—';

    // mode hint
    if (state.phase === 'review'){
      modePill.style.display = '';
      modeHint.textContent = state.reviewOnlyWrong ? '只回看錯題（鎖定）' : '回看全部題（鎖定）';
      timerPill.classList.add('muted');
    } else {
      modePill.style.display = 'none';
      modeHint.textContent = '';
      timerPill.classList.remove('muted');
    }

    renderNav(state);
    renderQuestion(state);
  }

  function tickTimer(state){
    if (state.phase === 'review'){
      timerEl.textContent = '—:—';
      return;
    }
    const remain = computeRemaining(state);
    timerEl.textContent = fmtTime(remain);
    if (remain <= 0){
      // 自動交卷（只做一次）
      if (!state.submitted){
        submitExam(state, true);
      }
    }
  }

  function submitExam(state, auto=false){
    if (state.submitted) return;
    state.submitted = true;
    writeState(state);

    const answers = state.answers || {};
    const items = state.questions.map((q) => {
      const sel = answers[q.qid];
      const ok = (sel !== undefined) && (sel === q.correctIndex);
      return {
        qid: q.qid,
        idx: q.idx,
        imgUrl: q.imgUrl,
        correctText: q.correctText,
        correctIndex: q.correctIndex,
        correctLetter: LETTERS[q.correctIndex],
        selectedIndex: (sel===undefined ? null : sel),
        selectedLetter: (sel===undefined ? null : LETTERS[sel]),
        selectedText: (sel===undefined ? null : q.options[sel]),
        ok
      };
    });

    const answeredCount = items.filter(x => x.selectedIndex !== null).length;
    const unansweredCount = items.length - answeredCount;
    const correctCount = items.filter(x => x.ok).length;
    const completionRate = items.length ? Math.round((answeredCount/items.length)*1000)/10 : 0;

    const result = {
      version: 2,
      studentId: state.studentId || '',
      total: items.length,
      durationSec: state.durationSec,
      startedAt: state.startAt,
      submittedAt: Date.now(),
      autoSubmit: !!auto,
      correctCount,
      score: correctCount,
      unansweredCount,
      completionRate,
      items
    };
    writeResult(result);

    // 交卷後進入結果頁
    location.href = './result.html';
  }

  async function init(){
    let state = readState();

    // 若沒有狀態 -> 回首頁
    if (!state){
      location.href = './index.html';
      return;
    }

    // 若已有成績而且是 review 入口（或 quiz 被人直接打開）：
    // - 若 submitted=true，預設導去 result
    if (state.submitted && state.phase !== 'review'){
      location.href = './result.html';
      return;
    }

    // 如果是回看模式但找不到成績，回首頁
    if (state.phase === 'review'){
      const r = safeParse(localStorage.getItem(LS.result) || 'null');
      if (!r) { location.href = './index.html'; return; }
      state.reviewPos = state.reviewPos || 0;
      writeState(state);
    }

    // 建立題目（若 index 沒有先產生）
    if (!Array.isArray(state.questions) || !state.questions.length){
      try{
        const pool = await fetchQuestionPool();
        const seed = (state.startAt || Date.now()) >>> 0;
        const questions = buildExamQuestions(pool, seed, 100);
        state.questions = questions;
        state.currentIndex = 0;
        writeState(state);
      }catch(err){
        alert('題庫讀取/建立失敗：\\n' + (err && err.message ? err.message : err));
        location.href = './index.html';
        return;
      }
    }

    // 如果從結果頁指定回看起始題
    if (state.phase === 'review' && typeof state.reviewStartIdx === 'number'){
      const list = ensureReviewList(state) || [];
      const pos = Math.max(0, Math.min(list.indexOf(state.reviewStartIdx), list.length-1));
      state.reviewPos = (pos >= 0 ? pos : 0);
      delete state.reviewStartIdx;
      writeState(state);
    }

    render(state);

    // events
    prevBtn.addEventListener('click', () => {
      const st = readState();
      if (st.phase === 'review'){
        setCurrentIndex(st, (st.reviewPos||0)-1);
      } else {
        setCurrentIndex(st, st.currentIndex-1);
      }
    });

    nextBtn.addEventListener('click', () => {
      const st = readState();
      if (st.phase === 'review'){
        setCurrentIndex(st, (st.reviewPos||0)+1);
      } else {
        setCurrentIndex(st, st.currentIndex+1);
      }
    });

    saveExitBtn.addEventListener('click', () => {
      // 僅回首頁（保留 state）
      location.href = './index.html';
    });

    submitBtn.addEventListener('click', () => {
      const st = readState();
      if (st.phase === 'review'){
        // 回看模式：回結果頁
        location.href = './result.html';
        return;
      }
      const ok = confirm('確定要交卷嗎？交卷後可在結果頁回看（可只看錯題）。');
      if (ok) submitExam(st, false);
    });

    // timer loop
    setInterval(() => {
      const st = readState();
      if (!st) return;
      tickTimer(st);
    }, 250);
  }

  init();
})();
</script>
</body>
</html>
